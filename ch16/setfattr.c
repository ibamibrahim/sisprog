/*
Implementation of setfattr utility (manpage contents below):

NAME
	setfattr - set extended attributes of filesystem objects

SYNOPSIS
	setfattr [-h] -n name [-v value] pathname...
	setfattr [-h] -x name pathname...
	setfattr [-h] --restore=file

DESCRIPTION
	The   setfattr  command  associates  a  new  value  with  an
	extended attribute name for each specified file.

OPTIONS

	-n name, --name=name
	    Specifies the name of the extended attribute to set.

	-v value, --value=value
	    Specifies the new value of the extended attribute. There
	    are three methods available  for encoding the value.  If
	    the given string is enclosed in double quotes, the inner
	    string is treated as text. In that case, backslashes and
	    double  quotes  have special  meanings  and  need to  be
	    escaped by a preceding backslash. Any control characters
	    can be  encoded as a backslash followed  by three digits
	    as its ASCII  code in octal. If the  given string begins
	    with 0x or 0X, it expresses a hexadecimal number. If the
	    given string  begins with 0s  or 0S, base64  encoding is
	    expected.    See   also   the   --encoding   option   of
	    getfattr(1).

	-x name, --remove=name
	    Remove the named extended attribute entirely.

	-h, --no-dereference
	    Do not follow symlinks.  If pathname is a symbolic link,
	    it  is not  followed, but  is instead  itself  the inode
	    being modified.

	--restore=file
	    Restores extended  attributes from file.   The file must
	    be in the format  generated by the getfattr command with
	    the --dump option.   If a dash (-) is  given as the file
	    name, setfattr reads from standard input.

	--version
	    Print the version of setfattr and exit.

	--help
	    Print help explaining the command line options.

	--  End of  command line options.   All remaining parameters
	    are interpreted as file names, even if they start with a
	    dash character.

AUTHOR
	Andreas Gruenbacher, <a.gruenbacher@bestbits.at> and the SGI
	XFS development team, <linux-xfs@oss.sgi.com>.

	Please send your bug reports or comments to these addresses.

SEE ALSO
	getfattr(1), and attr(5).

*/

#include <sys/xattr.h>
#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
#include <string.h>

static int no_deref_flag = 0;
static char *name = NULL;
static char *value = NULL;
static char *remove_name = NULL;

static struct option options[] = {
	/* flags */
	{"no-dereference",  no_argument, 0, 'h'},
	{"version", no_argument, 0, 'V'},
	{"help", no_argument, 0, 'H'},
	
	/* values */
	{"name", required_argument, 0, 'n'},
	{"value", required_argument, 0, 'v'},
	{"remove", required_argument, 0, 'x'},
	{0, 0, 0, 0},
};


void print_usage()
{
	printf("Usage: See man setfattr(1)\n");
	exit(EXIT_SUCCESS);
}

void print_version_and_exit()
{
	printf("setfattr (tlpi exercise) v0.1\n");
	exit(EXIT_SUCCESS);
}

int
parse_arguments(int argc, char **argv)
{
	int c;
	int option_index = 1;
	while ((c = getopt_long(argc, argv, "hVHn:v:x:", options, &option_index)) != -1) {
		switch (c) {
		case 'h':
			no_deref_flag = 1;
			break;
		case 'V':
			print_version_and_exit();
			break;
		case 'H':
			print_usage();
			break;
		case 'n':
			name = optarg;
			break;
		case 'v':
			value = optarg;
			break;
		case 'x':
			printf("Option -x: %s\n", optarg);
			remove_name = optarg;
			break;
	        case '?':
			break;
		default:
			abort();
		}
	}
	return 0;
}


int validate_arguments()
{
	if (name == NULL && remove_name == NULL) {
		fprintf(stderr, "Either '-n' or '-x' must be specified\n");
		print_usage();
	}
	if (name != NULL && remove_name != NULL) {
		fprintf(stderr, "Must specify only one of '-n' or '-x'\n");
		print_usage();
	}
	if (name != NULL && value == NULL) {
		fprintf(stderr, "Name specified without a value '-v'\n");
		print_usage();
	}
	return 0;
}

int do_set_attr(char **files, int count)
{
	char *file;
	int i;
	for (i = 0; i < count; i++) {
		file = files[i];
		if (setxattr(file, name, value, strlen(value), 0) == -1) {
			fprintf(stderr, "Unable to set attr '%s' on '%s'\n", name, file);
		}
	}
	return 0;
}

int do_remove_attr(char **files, int count)
{
	char *file;
	int i;
	for (i = 0; i < count; i++) {
		file = files[i];
		if (removexattr(file, remove_name) == -1) {
			fprintf(stderr, "Unable to remove attr '%s' on '%s'\n", remove_name, file);
		}
	}
	return 0;
}

int main(int argc, char **argv)
{
	int option_index = 0;
	parse_arguments(argc, argv);
	validate_arguments();
	if (name != NULL) {
		return do_set_attr(&argv[optind], argc - optind);
	} else {
		return do_remove_attr(&argv[optind], argc - optind);
	}
	return 1;
}
